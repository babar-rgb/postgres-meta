export interface ColumnDef {
    name: string;
    type: string;
    defaultValue?: string;
    isPrimaryKey: boolean;
    isNullable: boolean;
    isIdentity?: boolean; // For auto-incrementing IDs
}

export interface TableConfig {
    name: string;
    columns: ColumnDef[];
    enableRLS: boolean;
    realtime: boolean; // We likely won't implement realtime config logic yet, but good to have in state
}

export function generateTableSQL(config: TableConfig): string {
    const { name, columns, enableRLS } = config;

    // Basic validation
    if (!name.trim()) throw new Error("Table name is required");
    if (columns.length === 0) throw new Error("At least one column is required");

    let sql = `CREATE TABLE public.${name} (\n`;

    const colStrings = columns.map(col => {
        let parts = [col.name, col.type];

        if (col.isIdentity) {
            parts.push("GENERATED BY DEFAULT AS IDENTITY");
        }

        if (col.isPrimaryKey) {
            parts.push("PRIMARY KEY");
        }

        if (!col.isNullable && !col.isPrimaryKey) {
            parts.push("NOT NULL");
        }

        if (col.defaultValue) {
            // Simple logic to quote strings if needed, though usually postgres handles valid expressions
            // For simplicity, we assume the user types valid default expressions like 'default_value' or now()
            parts.push(`DEFAULT ${col.defaultValue}`);
        }

        return "  " + parts.join(" ");
    });

    sql += colStrings.join(",\n");
    sql += "\n);\n";

    if (enableRLS) {
        sql += `ALTER TABLE public.${name} ENABLE ROW LEVEL SECURITY;\n`;
    }

    return sql + "\n-- Reload PostgREST schema cache\nNOTIFY pgrst, 'reload schema';\n";
}
